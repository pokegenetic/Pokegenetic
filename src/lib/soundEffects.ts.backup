// Sistema de gesti√≥n de audio optimizado para m√≥viles y desktop
let audioContext: AudioContext | null = null;
let audioInitialized = false;
let pendingAudioQueue: Array<{soundType: string, volume: number, loop: boolean}> = [];
let firstInteractionDone = false;

// Detectar si es un dispositivo m√≥vil
export const isMobileDevice = () => {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
           (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);
};

// URLs de efectos de sonido desde GitHub Pages CDN (sin problemas de CORS)
const githubCDNSounds = {
    // Efectos de PC
    pc: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/pc.mp3',
    
    // Efectos de Pok√©ball
    pokeballcatch: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/pokeballcatch.mp3',
    pokeballthrow: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/pokeballthrow.mp3',
    pokeballexplode: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/pokeballexplode.mp3',
    pokeballwait: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/pokeballwait.mp3',
    pokeballreturn: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/pokeballreturn.mp3',
    pokeballopen: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/pokeballopen.mp3',
    pokeballwaiting: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/pokeballwaiting.mp3',
    pokeballthrowmasterball: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/pokeballthrowmasterball.mp3',
    
    // M√∫sica de captura
    catchmusic: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/catchmusic.mp3',
    catchmusicgo: 'https://pokegenetic.github.io/pokegenetic-audio/audio/catchmusicgo.mp3',
    catchedgo: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/catchedgo.mp3',
    
    // Efectos especiales
    superpower: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/superpower.wav',
    heal: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/heal.mp3',
    levelup: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/levelup.mp3',
    shiny: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/shiny.mp3',
    victory: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/victory.mp3',
    win: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/win.mp3',
    
    // Efectos de notificaci√≥n
    notification: 'https://pokegenetic.github.io/pokegenetic-audio/audio/notification.mp3',
    pop: 'https://pokegenetic.github.io/pokegenetic-audio/audio/notification.mp3',
    
    // M√∫sica de fondo
    pokechillmusic: 'https://pokegenetic.github.io/pokegenetic-audio/audio/pokechillmusic.mp3',
    pokemongym: 'https://pokegenetic.github.io/pokegenetic-audio/audio/pokemongym.mp3',
    wintrainer: 'https://pokegenetic.github.io/pokegenetic-audio/audio/wintrainer.mp3',
    gymbattle: 'https://pokegenetic.github.io/pokegenetic-audio/audio/gymbattle.mp3',
    trainerbattle: 'https://pokegenetic.github.io/pokegenetic-audio/audio/trainerbattle.mp3',
    wingym: 'https://pokegenetic.github.io/pokegenetic-audio/audio/wingym.mp3',
    obtainbadge: 'https://pokegenetic.github.io/pokegenetic-audio/audio/obtainbadge.mp3',
    casino: 'https://pokegenetic.github.io/pokegenetic-audio/audio/casino.mp3',
    
    // Juegos espec√≠ficos
    memorice: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/memorice.mp3',
    whosthat: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/whosthat.mp3',
    winrewards: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/winrewards.mp3',
    misterygift: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/misterygift.mp3',
    slot: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/slot.wav',
    nothing: 'https://pokegenetic.github.io/pokegenetic-audio/audio/sfx/nothing.mp3',
    
    // Efecto de error (a√±adiendo para compatibilidad)
    error: 'https://pokegenetic.github.io/pokegenetic-audio/audio/notification.mp3'
};

// Fallback a archivos locales (Vite los procesa autom√°ticamente)
const localSounds = {
    // Efectos de PC
    pc: '/sfx/pc.mp3',
    
    // Efectos de Pok√©ball
    pokeballcatch: '/sfx/pokeballcatch.mp3',
    pokeballthrow: '/sfx/pokeballthrow.mp3',
    pokeballexplode: '/sfx/pokeballexplode.mp3',
    pokeballwait: '/sfx/pokeballwait.mp3',
    pokeballreturn: '/sfx/pokeballreturn.mp3',
    pokeballopen: '/sfx/pokeballopen.mp3',
    pokeballwaiting: '/sfx/pokeballwaiting.mp3',
    pokeballthrowmasterball: '/sfx/pokeballthrowmasterball.mp3',
    
    // M√∫sica de captura
    catchmusic: '/sfx/catchmusic.mp3',
    catchmusicgo: '/catchmusicgo.mp3',
    catchedgo: '/sfx/catchedgo.mp3',
    
    // Efectos especiales
    superpower: '/sfx/superpower.wav',
    heal: '/sfx/heal.mp3',
    levelup: '/sfx/levelup.mp3',
    shiny: '/sfx/shiny.mp3',
    victory: '/sfx/victory.mp3',
    win: '/sfx/win.mp3',
    
    // Efectos de notificaci√≥n
    notification: '/notification.mp3',
    pop: '/notification.mp3',
    
    // M√∫sica de fondo
    pokechillmusic: '/pokechillmusic.mp3',
    pokemongym: '/pokemongym.mp3',
    wintrainer: '/wintrainer.mp3',
    gymbattle: '/gymbattle.mp3',
    trainerbattle: '/trainerbattle.mp3',
    wingym: '/wingym.mp3',
    obtainbadge: '/obtainbadge.mp3',
    casino: '/casino.mp3',
    
    // Juegos espec√≠ficos
    memorice: '/sfx/memorice.mp3',
    whosthat: '/sfx/whosthat.mp3',
    winrewards: '/sfx/winrewards.mp3',
    misterygift: '/sfx/misterygift.mp3',
    slot: '/sfx/slot.wav',
    nothing: '/sfx/nothing.mp3',
    
    // Efecto de error (a√±adiendo para compatibilidad)
    error: '/notification.mp3'
};

// Funci√≥n para obtener la URL del sonido con sistema de fallback
const getSoundUrl = (soundType: string, useLocal: boolean = false): string | null => {
    const soundMap = useLocal ? localSounds : githubCDNSounds;
    return soundMap[soundType as keyof typeof soundMap] || null;
};

// Funci√≥n mejorada para reproducir audio con sistema de fallback autom√°tico
const playAudioWithFallback = async (soundType: string, volume: number = 1.0, loop: boolean = false): Promise<HTMLAudioElement | null> => {
    // Intentar primero con CDN de GitHub
    let soundUrl = getSoundUrl(soundType, false);
    
    if (!soundUrl) {
        console.warn(`Tipo de sonido "${soundType}" no encontrado`);
        return null;
    }

    try {
        console.log(`üîä Intentando reproducir "${soundType}" desde CDN: ${soundUrl}`);
        const audio = new Audio(soundUrl);
        audio.volume = Math.max(0, Math.min(1, volume));
        audio.loop = loop;
        
        // Configurar timeout para el CDN
        const playPromise = audio.play();
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('CDN timeout')), 3000);
        });
        
        await Promise.race([playPromise, timeoutPromise]);
        console.log(`‚úÖ Sonido "${soundType}" reproducido desde CDN`);
        return audio;
        
    } catch (error) {
        console.warn(`‚ö†Ô∏è Error con CDN para "${soundType}":`, error);
        
        // Fallback a archivo local
        const localUrl = getSoundUrl(soundType, true);
        if (!localUrl) {
            console.error(`‚ùå No hay fallback local para "${soundType}"`);
            return null;
        }
        
        try {
            console.log(`üîÑ Intentando fallback local para "${soundType}": ${localUrl}`);
            const localAudio = new Audio(localUrl);
            localAudio.volume = Math.max(0, Math.min(1, volume));
            localAudio.loop = loop;
            
            await localAudio.play();
            console.log(`‚úÖ Sonido "${soundType}" reproducido desde archivo local`);
            return localAudio;
            
        } catch (localError) {
            console.error(`‚ùå Error tambi√©n con archivo local para "${soundType}":`, localError);
            return null;
        }
    }
};
const initializeAudioForMobile = (): Promise<void> => {
    return new Promise((resolve) => {
        try {
            if (typeof window !== 'undefined' && window.AudioContext) {
                audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
                
                audioContext.resume().then(() => {
                    console.log('üéµ AudioContext inicializado para m√≥vil');
                    audioInitialized = true;
                    firstInteractionDone = true;
                    
                    // Reproducir sonidos pendientes
                    pendingAudioQueue.forEach(({ soundType, volume, loop }) => {
                        playAudioDirectly(soundType, volume, loop);
                    });
                    pendingAudioQueue = [];
                    
                    resolve();
                }).catch((error) => {
                    console.warn('‚ö†Ô∏è Error inicializando audio:', error);
                    audioInitialized = true;
                    firstInteractionDone = true;
                    resolve();
                });
            } else {
                audioInitialized = true;
                firstInteractionDone = true;
                resolve();
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Error configurando sistema de audio:', error);
            audioInitialized = true;
            firstInteractionDone = true;
            resolve();
        }
    });
};

// Funci√≥n de inicializaci√≥n simplificada para m√≥viles
const initializeAudioForMobile = (): Promise<void> => {
    return new Promise((resolve) => {
        try {
            // Crear contexto de audio con la interacci√≥n del usuario
            if (!audioContext && typeof AudioContext !== 'undefined') {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioContext.resume().then(() => {
                    if (audioContext?.state === 'running') {
                        audioInitialized = true;
                        firstInteractionDone = true;
                        console.log('üîä Sistema de audio inicializado correctamente');
                        
                        // Procesar cola de sonidos pendientes
                        if (pendingAudioQueue.length > 0) {
                            console.log(`üìã Procesando ${pendingAudioQueue.length} sonidos en cola`);
                            pendingAudioQueue.forEach(({ soundType, volume, loop }) => {
                                playAudioWithFallback(soundType, volume, loop);
                            });
                            pendingAudioQueue = [];
                        }
                    }
                    resolve();
                }).catch(error => {
                    console.warn('‚ö†Ô∏è Error al reanudar contexto de audio:', error);
                    audioInitialized = true;
                    firstInteractionDone = true;
                    resolve();
                });
            } else {
                audioInitialized = true;
                firstInteractionDone = true;
                resolve();
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Error configurando sistema de audio:', error);
            audioInitialized = true;
            firstInteractionDone = true;
            resolve();
        }
    });
};

// Funci√≥n simplificada para reproducir audio directamente (DEPRECATED - usar playAudioWithFallback)
const playAudioDirectly = (soundType: string, volume: number = 1.0, loop: boolean = false): HTMLAudioElement | null => {
    // Verificar si el tipo de sonido es v√°lido
    if (!getSoundUrl(soundType, false) && !getSoundUrl(soundType, true)) {
        console.warn(`Tipo de sonido "${soundType}" no encontrado`);
        return null;
    }

    try {
        // Obtener la URL del sonido (primero CDN)
        const soundUrl = getSoundUrl(soundType, false);
        
        if (!soundUrl) {
            console.warn(`URL no encontrada para el sonido "${soundType}"`);
            return null;
        }

        // Crear un nuevo objeto Audio
        const audio = new Audio(soundUrl);
        
        // Configurar el volumen
        audio.volume = Math.max(0, Math.min(1, volume));
        
        // Configurar el loop
        audio.loop = loop;
        
        // Reproducir el sonido
        const playPromise = audio.play();
        
        // Manejar la promesa de reproducci√≥n
        if (playPromise !== undefined) {
            playPromise
                .then(() => {
                    console.log(`üîä Sonido "${soundType}" reproducido exitosamente`);
                })
                .catch(error => {
                    console.warn(`‚ö†Ô∏è Error al reproducir sonido "${soundType}":`, error);
                });
        }
        
        return audio;
    } catch (error) {
        console.error(`‚ùå Error al crear el objeto Audio para "${soundType}":`, error);
        return null;
    }
};

// Funci√≥n que replica el patr√≥n de pokemoncatch (que S√ç funciona)
export const playDirectAudio = (soundType: string, volume: number = 1.0, loop: boolean = false): HTMLAudioElement | null => {
    const soundUrl = soundEffects[soundType as keyof typeof soundEffects];
    
    if (!soundUrl) {
        console.warn(`Sonido "${soundType}" no encontrado en GitHub Pages CDN`);
        return null;
    }
    
    try {
        // Mismo patr√≥n que pokemoncatch
        const audio = new Audio(soundUrl);
        audio.volume = Math.max(0, Math.min(1, volume));
        audio.loop = loop;
        audio.play().catch(() => {
            console.warn(`Error reproduciendo sonido "${soundType}" desde GitHub Pages CDN`);
        });
        
        return audio;
    } catch (error) {
        console.error(`Error creando audio para "${soundType}":`, error);
        return null;
    }
};

// Funci√≥n principal para reproducir efectos de sonido
export const playSoundEffect = (soundType: string, volume: number = 1.0, loop: boolean = false): HTMLAudioElement | null => {
    // Si el audio no est√° inicializado y estamos en un dispositivo m√≥vil, agregar a la cola
    if (!audioInitialized && isMobileDevice()) {
        pendingAudioQueue.push({ soundType, volume, loop });
        console.log(`üìã Sonido "${soundType}" agregado a la cola (esperando inicializaci√≥n)`);
        return null;
    }
    
    // Reproducir el audio directamente
    return playAudioDirectly(soundType, volume, loop);
};

// Funci√≥n para verificar si el audio est√° inicializado
export const isAudioInitialized = () => {
    return audioInitialized;
};

// Configurar listeners para detectar la primera interacci√≥n del usuario
const setupFirstInteractionListeners = () => {
    if (firstInteractionDone || typeof window === 'undefined') return;
    
    const events = ['touchstart', 'touchend', 'mousedown', 'keydown', 'click'];
    
    const handleFirstInteraction = (event: Event) => {
        if (firstInteractionDone) return;
        
        console.log('üéØ Primera interacci√≥n detectada:', event.type);
        
        // Remover todos los listeners
        events.forEach(eventType => {
            document.removeEventListener(eventType, handleFirstInteraction, true);
        });
        
        // Inicializar audio si estamos en m√≥vil
        if (isMobileDevice()) {
            initializeAudioForMobile();
        } else {
            // En desktop, marcar como inicializado directamente
            audioInitialized = true;
            firstInteractionDone = true;
        }
    };
    
    // Agregar listeners para capturar la primera interacci√≥n
    events.forEach(eventType => {
        document.addEventListener(eventType, handleFirstInteraction, { capture: true, once: true });
    });
    
    console.log('üéµ Listeners de audio configurados para primera interacci√≥n');
};

// Auto-inicializar los listeners cuando se carga el m√≥dulo
if (typeof window !== 'undefined') {
    // En desktop, inicializar directamente
    if (!isMobileDevice()) {
        audioInitialized = true;
        firstInteractionDone = true;
        console.log('üñ•Ô∏è Desktop detectado: Audio habilitado directamente');
    } else {
        setupFirstInteractionListeners();
        console.log('üì± M√≥vil detectado: Esperando primera interacci√≥n para habilitar audio');
    }
}

// Exportar funciones utilitarias adicionales
export const getAvailableSounds = () => Object.keys(soundEffects);
export const getPendingAudioCount = () => pendingAudioQueue.length;

// Funciones para compatibilidad con c√≥digo existente
export const isAudioReady = () => audioInitialized;
export const forceAudioInitialization = () => {
    if (isMobileDevice() && !audioInitialized) {
        return initializeAudioForMobile();
    }
    return Promise.resolve();
};

// Funci√≥n para crear m√∫sica de fondo (patr√≥n pokemoncatch)
export const playBackgroundMusic = (soundType: string, volume: number = 0.03): HTMLAudioElement | null => {
    return playDirectAudio(soundType, volume, true); // loop = true para m√∫sica de fondo
};